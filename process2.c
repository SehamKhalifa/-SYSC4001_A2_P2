#include <stdio.h>      
#include <unistd.h>     
#include <sys/types.h>  
#include <stdlib.h>
#include <sys/shm.h>
#include <sys/sem.h>

typedef struct {
    int mult;
    int count;
} shmem_t;

void sema_wait(int semaid){
    struct sembuf sema_buffer = {0, -1, 0};
    if(semop(semaid, &sema_buffer, 1) == -1){
        perror("semop wait failed");
        exit(EXIT_FAILURE);
    }
}

void sema_sig(int semaid){
    struct sembuf sema_buffer = {0, 1, 0};
    if(semop(semaid, &sema_buffer, 1) == -1){
        perror("semop signal failed");
        exit(EXIT_FAILURE);
    }
}

int main(void) {
    printf("Process 2 (child, PID %d) started\n", getpid());
    int cycle_counter = 0;

    key_t key_mem = ftok(".", 'A'); // Use key generated by process 1
    if (key_mem == -1) {
        perror("Process 2: ftok failed");
        exit(EXIT_FAILURE);
    }

    int shmemid = shmget(key_mem, sizeof(shmem_t), 0666); // Access shared memory space
    if (shmemid == -1) {
        perror("Process 2: shmget failed");
        exit(EXIT_FAILURE);
    }

    shmem_t *shmem = (shmem_t *) shmat(shmemid, (void *) NULL, 0); // Attach to shared memory
        if (shmem == -1) {
        perror("Process 2: shmat failed");
        exit(EXIT_FAILURE);
    }

    printf("Process 2: Shared memory successfully attached\n");

    key_t key_sema = ftok(".", 'B'); // Use key generated by process 1
    if (key_sema == -1) {
        perror("sema ftok failed");
        exit(EXIT_FAILURE);
    }

    int semaid = semget(key_sema, 1, 0666); // Create semaphore
    if(semaid == -1){
        perror("semget failed");
        exit(EXIT_FAILURE);
    }

    printf("Process 2: Semaphore successfully initialized\n");
    while (1) {
        sema_wait(semaid);
        if(shmem->count > 100){
            // Check if cycle is a multiple of mult chosen
            if (cycle_counter % shmem->mult == 0) {
                printf("Process 2 - Cycle number: %d - %d is a multiple of %d\n", cycle_counter, cycle_counter, shmem->mult);
            } else {
                printf("Process 2 - Cycle number: %d\n", cycle_counter);
            }

            // Check if reached the exit condition
            if (cycle_counter <= -500) {
                sema_sig(semaid);
                printf("\nProcess 2: Reached %d (lower than -500)\n", cycle_counter);
                printf("Process 2: Exiting now...\n");
                exit(0);  // Exit with status 0 (success)
            }

            if(shmem->count > 500){
                sema_sig(semaid);
                printf("\nProcess 2: Shared value reached 500\n");
                printf("Process 2: Exiting now...\n");
                exit(0);
            }

            cycle_counter--;
        }
        sema_sig(semaid);
        usleep(200000);   // sleep 0.5s to slow output
    }

    shmdt(shmem); // Clean up
    printf("Process 2: Shared memory and semaphore succesfully cleaned up\n");

    return 0;
}
